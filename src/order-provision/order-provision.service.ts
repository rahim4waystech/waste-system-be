
import { OrderProvision } from "./order-provision.entity";
import { Injectable } from "@nestjs/common";
import { InjectRepository } from "@nestjs/typeorm";

import { TypeOrmCrudService } from "@nestjsx/crud-typeorm";

/**
 * This file was generated by Four Ways Technology
 *
 * On Thu Sep 07 2023 10:10:45 GMT+0100 (British Summer Time)
 */
@Injectable()
export class OrderProvisionService extends TypeOrmCrudService<OrderProvision> {
  constructor(@InjectRepository(OrderProvision) repo) {
    super(repo);
  }

  async getOrdersForArtic(date:string, page:number=1, amount:number=10, search: string='', sort:string='time') {


    let orderBySQL = '';

    if(sort === 'time') {
      orderBySQL = ' ORDER BY order.time asc';
    }

    if(sort === "account") {
      orderBySQL = ' ORDER BY account.name desc';
    }

    if(sort === "po-number") {
      orderBySQL = ' ORDER BY order.poNumber asc';
    }

    const offset = (page-1) * amount;
    const params: any[] = [date, date, date, date,date,date,date,date,date,date,date];


    let searchSQL = '';
    if(search !== '') {
      searchSQL = ' and account.name LIKE ?';
      params.push('%' + search + '%');
    }

    params.push(offset);
 
    const results = await this.repo.query(`
SELECT \`order\`.id FROM \`order\`
LEFT JOIN order_type on order_type.id = \`order\`.orderTypeId
LEFT JOIN account on account.id = \`order\`.accountId
-- Standard query for date range
where \`order\`.id in (
	select id from \`order\`
    where \`order\`.orderStatusId = 2 and
    (\`order\`.contractId is null or \`order\`.contractId = -1)
	and \`order\`.date = ?
) or \`order\`.id in 
-- Recurrence
(
	SELECT \`order\`.id
FROM   \`order\`
INNER JOIN contract on contract.id = \`order\`.contractId
INNER JOIN recurrence on contract.recurrenceId = recurrence.id
WHERE  ( recurrencetype = 'daily'
         AND Mod(Dayofweek(?), recurrence.timevalue) = 0 )
        OR ( recurrencetype = 'weekly'
             AND Mod(Week(?), recurrence.timevalue) = 0 )
        OR ( recurrencetype = 'monthByDayNo'
             AND Day(?) = recurrence.recurrencedayno
             AND Mod(Month(?), recurrence.recurrencemonthno) = 0 )
        OR ( recurrencetype = 'monthByDay'
             AND Floor((Dayofmonth(CURRENT_DATE()) - 1) / 7)
                 + 1 = recurrence.recurrenceweekno
             AND Dayofweek(?) = recurrence.recurrencedayno )
        OR ( recurrencetype = 'year'
             AND Mod(( ? ), recurrence.timevalue) = 0 )
        OR ( recurrencetype = 'yearByDayNo'
             AND Month(?) = recurrence.recurrencemonthno
             AND Day(?) = recurrence.timevalue )
        OR ( recurrencetype = 'yearByDay'
             AND Floor((Dayofmonth(CURRENT_DATE()) - 1) / 7)
                 + 1 = recurrence.recurrenceweekno
             AND Dayofweek(?) = recurrence.recurrencedayno
             AND Month(?) = recurrence.recurrencemonthno )
)

-- other conditions
and orderTypeId = 8
and orderStatusId = 2
${searchSQL}

${orderBySQL}

-- Other (Pagination for the nation)
limit 10 offset ?
    `, params);



    let countParams = params;
    countParams.pop();
    const count = await this.repo.query(`
    SELECT count(*) FROM \`order\`
    LEFT JOIN order_type on order_type.id = \`order\`.orderTypeId
    LEFT JOIN account on account.id = \`order\`.accountId
    -- Standard query for date range
    where \`order\`.id in (
      select id from \`order\`
        where \`order\`.orderStatusId = 2 and
        (\`order\`.contractId is null or \`order\`.contractId = -1)
      and \`order\`.date = ?
    ) or \`order\`.id in 
    -- Recurrence
    (
      SELECT \`order\`.id
    FROM   \`order\`
    INNER JOIN contract on contract.id = \`order\`.contractId
    INNER JOIN recurrence on contract.recurrenceId = recurrence.id
    WHERE  ( recurrencetype = 'daily'
             AND Mod(Dayofweek(?), recurrence.timevalue) = 0 )
            OR ( recurrencetype = 'weekly'
                 AND Mod(Week(?), recurrence.timevalue) = 0 )
            OR ( recurrencetype = 'monthByDayNo'
                 AND Day(?) = recurrence.recurrencedayno
                 AND Mod(Month(?), recurrence.recurrencemonthno) = 0 )
            OR ( recurrencetype = 'monthByDay'
                 AND Floor((Dayofmonth(CURRENT_DATE()) - 1) / 7)
                     + 1 = recurrence.recurrenceweekno
                 AND Dayofweek(?) = recurrence.recurrencedayno )
            OR ( recurrencetype = 'year'
                 AND Mod(( ? ), recurrence.timevalue) = 0 )
            OR ( recurrencetype = 'yearByDayNo'
                 AND Month(?) = recurrence.recurrencemonthno
                 AND Day(?) = recurrence.timevalue )
            OR ( recurrencetype = 'yearByDay'
                 AND Floor((Dayofmonth(CURRENT_DATE()) - 1) / 7)
                     + 1 = recurrence.recurrenceweekno
                 AND Dayofweek(?) = recurrence.recurrencedayno
                 AND Month(?) = recurrence.recurrencemonthno )
    )
    
    -- other conditions
    and orderTypeId = 8
    and orderStatusId = 2
    ${searchSQL}
    
    ${orderBySQL}
    
    -- Other (Pagination for the nation)
        `, countParams);

    const ids = [];
    results.forEach((result) => {
      ids.push(result.id);
    });
    
    if(ids.length === 0) {
      return {count: 0, data: []};
    }
    // now do a query builder query to get orders based on ids from inital query
    const query = this.repo.createQueryBuilder()
    .whereInIds(ids)
    .leftJoinAndSelect('updatedUser', 'updatedUser')
    .leftJoinAndSelect('orderType', 'orderType')
    .leftJoinAndSelect('account', 'account')
    .leftJoinAndSelect('site', 'site')
    .leftJoinAndSelect('orderStatus', 'orderStatus')
    .leftJoinAndSelect('skipOrderType', 'skipOrderType')
    // .leftJoinAndSelect('containerSizeType', 'containerSizeType')
    // .leftJoinAndSelect('containerSizeType.unit', 'containerSizeType.unit')
    .leftJoinAndSelect('containerType', 'containerType')
    .leftJoinAndSelect('grade', 'grade')
    .leftJoinAndSelect('tipSite', 'tipSite')
    
    return {data: await query.getMany(), count: count[0]['count(*)']};
  }

  async updateSingleToAllocatedByOrderIdAndDate(orderId:number=-1, date:string='') {
    await this.repo.query(`
    update order_provision
    set allocated = 1
    where orderId = ?
    AND date = ?
    AND allocated <=0
    order by orderId desc
    limit 1
  `, [orderId, date]);
}


  async deleteSingleProvisionByOrderId(orderId: number=-1, date:string='') {
    await this.repo.query(`
      delete from order_provision 
      where orderId = ?
      AND date = ?
      order by orderId desc
      limit 1
    `, [orderId, date]);
  }
}
