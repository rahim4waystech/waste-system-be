
import { Reporting } from "./reporting.entity";
import { Injectable } from "@nestjs/common";
import { InjectRepository } from "@nestjs/typeorm";

import { TypeOrmCrudService } from "@nestjsx/crud-typeorm";

/**
 * This file was generated by Four Ways Technology
 *
 * On Mon Jan 18 2021 10:06:58 GMT+0000 (Greenwich Mean Time)
 */
@Injectable()
export class ReportingService extends TypeOrmCrudService<Reporting> {
  constructor(@InjectRepository(Reporting) repo) {
    super(repo);
  }

  async getUtilisationForDateRange(data){
    const startDate = data.startDate;
    const endDate = data.endDate;

    return await this.repo.manager.query(`
      SELECT
      	vehicleType,
          available,
          available / (available + maintenance) * 100 AS available_percent,
          maintenance,
          maintenance / (maintenance + available) * 100 AS maintenance_percent,
          No_Work,
          No_Work / (No_Work + Working) * 100 AS No_Work_percent,
          Working,
          Working / (Working + No_Work) * 100 AS Working_percent
      FROM
          (SELECT
              v.vehicleTypeId,
                  COUNT(IF(vv.vehicleId IS NOT NULL, 1, NULL)) AS available,
                  COUNT(IF(vv.vehicleId IS NULL, 1, NULL)) AS maintenance,
      		vehicle_type.name as vehicleType
          FROM
              vehicle v
          LEFT JOIN (SELECT
              vehicleId
          FROM
              vehicle_vor
          WHERE
              startDate >= ?
                  AND endDate <= ?
          GROUP BY vehicleId) vv ON v.Id = vv.vehicleId
          left join vehicle_type on vehicle_type.id = v.vehicleTypeId
          GROUP BY v.vehicleTypeId) AS A
              INNER JOIN
          (SELECT
              vehicleTypeId,
                  COUNT(IF(j.id IS NULL, 1, NULL)) AS No_Work,
                  COUNT(IF(j.id IS NOT NULL, 1, NULL)) AS Working
          FROM
              job_assignment ja
          LEFT JOIN job j ON ja.id = j.jobAssignmentId
          INNER JOIN vehicle v ON v.id = ja.vehicleId
          WHERE
              ja.date BETWEEN ? AND ?
          GROUP BY vehicleTypeId) AS B ON A.vehicleTypeId = B.vehicleTypeId
    `,[startDate,endDate,startDate,endDate]);
  }

  async getNetIncomeByVehicle(data){
    const startDate = data.startDate;
    const endDate = data.endDate;

    return await this.repo.manager.query(`
      select
      	vehicle.registration,
      	A.vehicleId,
          D.Gross_Income,
          ifnull(B.CoS,0) as CoS,
          D.Gross_income-ifnull(B.CoS,0)as Net_Income,
          C.Fuel_Cost,
      	C.Fuel_Cost/(D.Gross_income-ifnull(B.CoS,0) )*100  as Fuel_Percent,
          E.Wages,
          A.Shifts,
          (D.Gross_income-ifnull(B.CoS,0))/A.Shifts as Pounds_Avg
      from
      	(
          	select vehicleId, count(*) as Shifts from job_assignment
      		where job_assignment.date between ? and ?
      		group by vehicleId
      	) as A
      	left join
          	(
      			select ja.vehicleId, sum(ifnull(tp.price,0))  as CoS from job j
      			inner join tipping_prices tp on j.tippingPriceId = tp.id
      			inner join job_assignment ja on ja.id=j.jobAssignmentId
      			 where ja.date between ? and ?
      			group by ja.vehicleId
          	) as B
      	on A.vehicleId=B.vehicleId
      	left join
          	(
      			select f.vehicleId, sum(f.fuel* fp.price) as fuel_cost from fuel f
      			inner join vehicle v on f.vehicleId = v.id
      			 inner join fuel_price fp on fp.fuelTypeId = v.fuelTypeId
      			and fp.effectiveDate = (select effectiveDate from fuel_price where f.date>effectiveDate order by effectiveDate desc limit 1)
      			where f.date between ? and ?
      			group by f.vehicleId
          	) as C
      	on A.vehicleId=C.vehicleId
      	left join
          	(
      			select ja.vehicleId, sum(ii.qty*price) as Gross_Income from invoice_item ii
      			inner join job j on ii.jobId = j.id
      			inner join job_assignment ja on ja.id=j.jobAssignmentId
      			where ii.date between ? and ?
      			group by ja.vehicleId
          	) as D
      	on A.vehicleId=D.vehicleId
      	left join
          	(
      			select ja.vehicleId,sum(chargeableHours*8.91) as Wages from job_assignment ja
      			inner join driver d on ja.driverId = d.id
      			inner join driver_hours dh on d.id=dh.driverid
      			where ja.date between ? and ?
      			group by ja.vehicleId
          	) as E
      	on A.vehicleId=E.vehicleId
      left join vehicle on vehicle.id = A.vehicleId
    `,[startDate,endDate,startDate,endDate,startDate,endDate,startDate,endDate,startDate,endDate]);
  }

  async getDebtorsReport(data){
    const startDate = data.startDate;
    const endDate = data.endDate;

    return await this.repo.manager.query(`
      select
        account.name,
        account.onStop,
        account.limitEnabled,
        credit_limit.maxCredit,
        credit_limit.usedCredit,
        ROUND(credit_limit.usedCredit * 100.0 / credit_limit.maxCredit, 1) AS percent
      FROM
        account
      LEFT JOIN credit_limit on credit_limit.accountId = account.id
      WHERE
        (
          account.limitEnabled = 1
        AND
          ROUND(credit_limit.usedCredit * 100.0 / credit_limit.maxCredit, 1) > 90
        )
      or
        account.onStop = 1
    `);
  }

  async getDefectStats(){
    return await this.repo.manager.query(`
      select
      	count(distinct vehicle.registration) as total,
          (
      		select count(distinct defects.vehicleId)
              from vehicle
              left join defects on defects.vehicleId = vehicle.id
              where defects.ended IS NULL
      	) as openDefects,
          (
      		select count(distinct defects.vehicleId)
              from vehicle
              left join defects on defects.vehicleId = vehicle.id
              where defects.vehicleSeverityId < 3 and defects.ended IS NULL
      	) as openVor
      from
      	vehicle
    `);
  }
}
