
import { Invoice } from "./invoice.entity";
import { Crud, CrudController, CrudRequestInterceptor, ParsedRequest, CrudRequest, Feature, Action } from "@nestjsx/crud";
import { Controller, UseInterceptors, Post, Param, Body, Get } from "@nestjs/common";
import { InvoiceService } from "./invoice.service";
import { Job } from "src/job/job.entity";
import { CustomerDetailsService } from "src/customer-details/customer-details.service";
import { CustomerDetails } from "src/customer-details/customer-details.entity";
import { InvoiceItemService } from "src/invoice-item/invoice-item.service";
import * as htmlPdf from 'html-pdf-chrome';
import { PDFService } from "src/core/pdf.service";
import { Account } from "src/account/account.entity";
import { v4 as uuidv4 } from 'uuid';
import { MailService } from "src/core/mail.service";
import * as fs from 'fs';
import * as moment from 'moment';
import { UnitService } from "src/unit/unit.service";
import { DriverJobMovementService } from "src/driver-job-movement/driver-job-movement.service";
import { DriverJobStatusDetailsService } from "src/driver-job-status-details/driver-job-status-details.service";
import { DriverJobStatusDetails } from "src/driver-job-status-details/driver-job-status-details.entity";
import { DocumentsService } from "src/documents/documents.service";
import { InvoiceItem } from "src/invoice-item/invoice-item.entity";
import { In } from "typeorm";
import { DriverJobMovement } from "src/driver-job-movement/driver-job-movement.entity";
import { VehicleService } from "src/vehicle/vehicle.service";
import { JobService } from "src/job/job.service";
import { YardTrade } from "src/yard-trade/yard-trade.entity";
import { TipTicketService } from "src/tip-ticket/tip-ticket.service";
import { TipTicket } from "src/tip-ticket/tip-ticket.entity";
import { OrderLine } from "src/order-line/order-line.entity";
import { OrderLineService } from "src/order-line/order-line.service";
import { InvoiceEmailLogService } from "src/invoice-email-log/invoice-email-log.service";
import { InvoiceEmailLog } from "src/invoice-email-log/invoice-email-log.entity";


/**
 * This file was generated by Four Ways Technology
 *
 * On Wed Sep 23 2020 14:21:52 GMT+0100 (British Summer Time)
 */
@Crud({
  model: {
    type: Invoice
  },
  query: {
    join: {
      account: {
        eager: true
      },
      orderType: {
        eager: true
      },
      taxType: {
        eager: true
      },
      invoicePeriod: {
        eager: true
      },
      job: {
        eager: false,
      },
      order: {
        eager: false,
      }
    }
  }
})
@Controller('invoice')
@Feature('invoice')
export class InvoiceController implements CrudController<Invoice> {
  constructor(public service: InvoiceService,
    private pdfService: PDFService,
    private unitService: UnitService,
    private jobService: JobService,
    private orderLineService: OrderLineService,
    private mailService: MailService,
    private documentsService: DocumentsService,
    private tipTicketService: TipTicketService,
    private invoiceEmailLogService: InvoiceEmailLogService,
    private driverJobStatusDetailsService: DriverJobStatusDetailsService,
    private driverJobMovementService: DriverJobMovementService,
    private invoiceItemService: InvoiceItemService,
    private customerDetailsService: CustomerDetailsService) { }

  

    @UseInterceptors(CrudRequestInterceptor)
    @Action('assignYardTrade')
    @Post('assignYardTrade')
    async assignYardTrade(@ParsedRequest() req: CrudRequest, @Param() params, @Body() data: any) {
      const jobs: YardTrade[] = data.bulk;
    
  
      for(let i = 0; i < jobs.length; i++) {
        const job = jobs[i];
  
        let invoiceId = -1;
        let split = []
  
        // get customer details
        let customerDetails = await this.customerDetailsService.findOne({where: {
          accountId: job.customerId,
        }});
  
        if(!customerDetails) {
          customerDetails = new CustomerDetails();
          customerDetails.invoiceSplitByOrderType = true;
          customerDetails.invoiceSplitByPO = true;
          customerDetails.invoiceSplitBySite = true;
          customerDetails.invoicePeriodId = 1;
          customerDetails.invoiceMethodId = 1;
        }
  
        // override from frontend
        // if(data.extra.customerDetails) {
        //   customerDetails = data.extra.customerDetails;
        // }
    
    
        if (customerDetails.invoiceSplitByOrderType) {
          split.push('orderType');
        }
    
        if (customerDetails.invoiceSplitByPO) {
          split.push('po');
        }
    
        if (customerDetails.invoiceSplitBySite) {
          split.push('site');
        }

     
        let invoice = await this.service.findAvaliableInvoiceForYardTrade(job);
        if (invoice !== undefined) {
          invoiceId = invoice.id;
        } else {
          invoice = await this.service.createInvoiceFromYardTrade(job, customerDetails);
        }
    
        // create invoices items for job and associate to invoice
        await this.invoiceItemService.createInvoiceItemsFromYardTrade(job, invoice);
      }
  
      return jobs;
    }

    
  @UseInterceptors(CrudRequestInterceptor)
  @Action('assignJobs')
  @Post('assignJobs')
  async assignJobs(@ParsedRequest() req: CrudRequest, @Param() params, @Body() data: any) {
    const jobs = data;
    let ticketType = 1;
    let date = null;
    let confirmation = false;
    let invoiceNumber = -1;
    let invoices = [];
    let currentItems= [];

    let doneJobs = [];

    if(data.extra.date) {
      date = data.extra.date;
    }

    if(data.extra.ticketType) {
      ticketType = data.extra.ticketType;
    }

    if(data.extra.confirmation) {
      confirmation = data.extra.confirmation;
    }

    if(data.extra.invoiceNumber) {
      invoiceNumber = data.extra.invoiceNumber;
    }

    //remove duplicate items
    jobs.bulk.forEach((job: Job, index: number) => {
      if(currentItems.indexOf(job.id) === -1) {
        currentItems.push(job.id);
      } else {
        jobs.bulk.splice(index, 1);
      }
    });
 

    for(let i = 0; i < jobs.bulk.length; i++) {
      const job = jobs.bulk[i];

      let invoiceId = -1;
      let split = [];
  


      if(doneJobs.indexOf(job.id) !== -1) {
        // we've already done this job skip over it.
        continue;
      
      } else {
        doneJobs.push(job.id);
      }

      // get customer details
      let customerDetails = await this.customerDetailsService.findOne({where: {
        accountId: job.order.accountId
      }});

      if(!customerDetails) {
        customerDetails = new CustomerDetails();
        customerDetails.invoiceSplitByOrderType = true;
        customerDetails.invoiceSplitByPO = true;
        customerDetails.invoiceSplitBySite = true;
        customerDetails.invoicePeriodId = 1;
        customerDetails.invoiceMethodId = 1;
      }

      // override from frontend
      if(data.extra.customerDetails) {
        customerDetails = data.extra.customerDetails;
      }
  
  
      if (customerDetails.invoiceSplitByOrderType) {
        split.push('orderType');
      }
  
      if (customerDetails.invoiceSplitByPO) {
        split.push('po');
      }
  
      if (customerDetails.invoiceSplitBySite) {
        split.push('site');
      }

      let env = process.env.NODE_ENV || 'development';

      // only auto batch for rio's ynd didn't want this
      if(env === 'rwm' || env === 'murdoch') {
        if (split.length === 0) {
          split = ['po', 'site', 'orderType'];
         }
      }
   
      let invoice = await this.service.findAvaliableInvoice(job, split);
      if (invoice !== undefined) {
        invoiceId = invoice.id;
      } else {
       invoice = await this.service.createInvoiceFromJob(job, customerDetails, ticketType, date, confirmation, invoiceNumber);
      }

      // only push if not in array already
      if(invoices.filter(i => i.id === invoice.id).length === 0) {
        invoices.push(invoice);
      }
  
      // create invoices items for job and associate to invoice
      await this.invoiceItemService.createInvoiceItemsFromJob(job, invoice);
    }


    // look for additional charges such as per load etc and process different
    // create an invoice infront for these 

    // let invoice = null;
    // for(let i = 0; i < jobs.bulk.length; i++) {
    //   const job = jobs.bulk[i];

    //   let orderLines: OrderLine[] = await this.orderLineService.getAllOrderLinesForOrderId(job.order.id);

    //   // additional charge present
    //   if(orderLines.length > 1) {
    //     if(invoice === null) {
    //       let customerDetails = new CustomerDetails();
    //       customerDetails.invoiceSplitByOrderType = true;
    //       customerDetails.invoiceSplitByPO = true;
    //       customerDetails.invoiceSplitBySite = true;
    //       customerDetails.invoicePeriodId = 1;
    //       customerDetails.invoiceMethodId = 1;

    //       invoice = await this.service.createInvoiceFromJob(job, customerDetails, ticketType, date, false, -1, true);
    //       invoices.push(invoice);
    //     }
    //     await this.invoiceItemService.createInvoiceAdditionalChargeItemsFromJob(job, invoice, orderLines);
    //   }
      
    // }

    return invoices;
  }


  @UseInterceptors(CrudRequestInterceptor)
  @Action('preview')
  @Post('preview')
  async preview(@ParsedRequest() req: CrudRequest, @Param() params, @Body() data: any) {
    const jobs = data;
    let ticketType = 1;
    let date = null;
    let confirmation = false;
    let invoiceNumber = -1;
    let doneJobs = [];

    if(data.extra.date) {
      date = data.extra.date;
    }

    if(data.extra.ticketType) {
      ticketType = data.extra.ticketType;
    }

    if(data.extra.confirmation) {
      confirmation = data.extra.confirmation;
    }

    if(data.extra.invoiceNumber) {
      invoiceNumber = data.extra.invoiceNumber;
    }

    const invoices = [];
    let items = [];
  

    for(let i = 0; i < jobs.bulk.length; i++) {
      const job = jobs.bulk[i];

      let invoiceId = -1;
      let split = [];

      if(doneJobs.indexOf(job.id) !== -1) {
        // we've already done this job skip over it.
        continue;
      } else {
        doneJobs.push(job.id);
      }

      // get customer details
      let customerDetails = await this.customerDetailsService.findOne({where: {
        accountId: job.order.accountId
      }});

      if(!customerDetails) {
        customerDetails = new CustomerDetails();
        customerDetails.invoiceSplitByOrderType = true;
        customerDetails.invoiceSplitByPO = true;
        customerDetails.invoiceSplitBySite = true;
        customerDetails.invoicePeriodId = 3;
        customerDetails.invoiceMethodId = 1;
      }

      // override from frontend
      if(data.extra.customerDetails) {
        customerDetails = data.extra.customerDetails;
      }
  
  
      if (customerDetails.invoiceSplitByOrderType) {
        split.push('orderType');
      }
  
      if (customerDetails.invoiceSplitByPO) {
        split.push('po');
      }
  
      if (customerDetails.invoiceSplitBySite) {
        split.push('site');
      }
  
      if (split.length === 0) {
        split = ['po', 'site', 'orderType'];
      }

      // check to see if candiate
      let invoice = null;

      invoices.forEach((currentinvoice) => {
        if(currentinvoice.accountId === job.order.accountId) {
          invoice = currentinvoice;
        }
      });

      if(invoice === null) {
        invoice = await this.service.createInvoiceObject(job, customerDetails, ticketType, date, confirmation, invoiceNumber);
        invoice.id = i * -1;
        invoices.push(invoice);
      }

      
      // create invoices items for job and associate to invoice
      let newItems = await this.invoiceItemService.createInvoiceItemsFromJobObjects(job, invoice);

      // Set fake neg id
      newItems.forEach((item) => {
        item.invoiceId = invoice.id;
      })
    
      items = items.concat(newItems);
      
    }

    // generate invoice pdf


    let templateData = {datasets: []};

    let template = data.extra.type;

    const invoicingInfo = data.extra.pdfSettings;

    const showPods = data.extra.pods;

    if(template === 1) {
      template = data.extra.pdfSettings.headedInvoiceTemplate;
    } else if(template === 2) {
      template = data.extra.pdfSettings.unheadedInvoiceTemplate;
    }

    for(let i = 0; i < invoices.length; i++) {


    const invoice = invoices[i];

    const invoiceItems: any[] = items.filter(i => i.invoiceId === invoice.id);


    invoiceItems.forEach((item) => {
      item.longDescription = item.longDescription.replace(/\n\r?/g, '<br />');
    });

    
    let subtotal = 0;
    let vatTotal = 0;
    let total = 0;
    let qtyTotal = 0;

    invoiceItems.forEach((item) => {
      item.total = item.qty * item.price;
      subtotal += item.total;
      qtyTotal += item.qty;
      if(invoiceItems[0].orderLine?.unit?.name !== 'Load') {
        item.qty =  item.qty.toFixed(2);
      };
	    item.total = item.total.toFixed(2);

      if(item.longDescription.indexOf('/') !== -1) {
        item.longDescription = this.truncateValueForTickets(item.longDescription).join('<br />');
      }
    })

    const vatPercentage = <any>invoice.taxType.rate / 100;
    vatTotal = subtotal * vatPercentage;

    total = vatTotal + subtotal;

    // GET PODS

    const jobIds = invoiceItems.map((ii: InvoiceItem) => ii.jobId);

    let pods = [];


    if(jobIds.length === 0) {
      pods = [];
    } else {
      pods = await this.driverJobMovementService.find({where: {jobId: In(jobIds)}, relations: ["vehicle", "driver", "job","job.order","job.order.grade", "job.order.account","job.order.site", "job.order.orderLines", "job.order.orderLines.quoteLine", "job.order.orderLines.quoteLine.product"]})
    }

    const units = await this.unitService.find();


    const podData = [
    ]

      for(let podi = 0; podi < pods.length; podi++) {
        const pod: any = pods[podi];



        let historyData = await this.driverJobStatusDetailsService.getAllHistoryByJobId(pod.job.id);
        const jobMovements = await this.driverJobMovementService.find({
          where: {
            jobId: pod.job.id
          },
          select: ['id'],
        });
        
        let history = this.groupJobMovementHistory(historyData)[this.findPositionInMovements(jobMovements, pod.id)];
        
        if(!history) {
          history = [];
        }
        const imagesRaw = await this.documentsService.getDocumentsByEntityNameAndId("driver-job-movement", pod.id);
        const images = []

        // get all files from filesystem
        imagesRaw.forEach((document) => {
          const path = __dirname + "/../../files/"  + document.filename;
          const contents = fs.readFileSync(path, {encoding: 'base64'});
          images.push({
            filetype: document.filetype,
            filename:document.originalFilename,
            data: contents.toString()
          });
        })

        podData.push({
          pod: pod,
          order: pod.job.order,
          companyName: invoicingInfo.companyName,
          addressInfo: this.getCompanyAddress(invoicingInfo),
          companyLogo: invoicingInfo.companyLogo,
          service: this.getService(pod.job.order.orderLines),
          serviceUnit: this.getUnit(pod.job.order.orderLines, units),
          serviceAmount: pod.qty,
          siteAddress: this.getSiteAddress(pod.job.order),
          signatureDetails: this.getSignatureDetails(history),
          images: images,
          tipDetails: [],
          gpsCordsForSignature :history.filter(h => h.driverJobStatusId === 4)[0],
        })
    }


    let qtyTotalOutput:any = '';

    if(invoiceItems[0].orderLine?.unit.name === 'Load') {
      qtyTotalOutput = qtyTotal;
    } else {
      qtyTotalOutput = qtyTotal.toFixed(2);
    }

  
    templateData.datasets.push({
        customerAddress: this.getAddressDetails(invoice.account),
        invoiceNumber: data.extra.pdfSettings.invoicePrefix + invoice.id,
        invoiceDate: moment(invoice.invoiceDate).format('DD/MM/YYYY'),
        customerRef: invoice.account.accountRef,
        invoiceItems: invoiceItems,
        confirmation: invoice.confirmation,
        subtotal: subtotal.toFixed(2),
        vatTotal: vatTotal.toFixed(2),
        qtyTotal: qtyTotalOutput,
        total: total.toFixed(2),
        loadEx: invoice.loadEx,
        poNumber: invoice.poNumber,
        podsHTML: podData.length > 0 && showPods && !invoice.isAdditionalCharge ? await this.pdfService.createPDFUsingTemplate(data.extra.pdfSettings.podTemplate, '', {datasets: podData}, true) : '',
        vatRate: invoice.taxType.rate,
        invoiceSettings: data.extra.pdfSettings,
        showPods: showPods,
        tipMappings: [],
        jobTipMappings: {},
        tipChecks: false,
    });

  }


  templateData = await this.generateAdditionalChargePreviewObjects(data, templateData);

  const batchId = uuidv4();
   await this.pdfService.createPDFUsingTemplate(template,  __dirname + '/../../assets/invoice/batch/preview-' + data.extra.pdfSettings.invoicePrefix + batchId, templateData);

   return { fileName: '/invoice/batch/preview-' + data.extra.pdfSettings.invoicePrefix + batchId+'.pdf' };

  }

  private async generateAdditionalChargePreviewObjects(data: any, templateData:any) {
    const jobs = data;
    let ticketType = 1;
    let date = null;
    let confirmation = false;
    let invoiceNumber = -1;

    if(data.extra.date) {
      date = data.extra.date;
    }

    if(data.extra.ticketType) {
      ticketType = data.extra.ticketType;
    }

    if(data.extra.confirmation) {
      confirmation = data.extra.confirmation;
    }

    if(data.extra.invoiceNumber) {
      invoiceNumber = data.extra.invoiceNumber;
    }

    const invoices = [];
    let items = [];
  


      // check to see if candiate
      let invoice = null;

    for(let i = 0; i < jobs.bulk.length; i++) {
      const job = jobs.bulk[i];

      let invoiceId = -1;
      let split = []

      // get customer details
      let customerDetails = await this.customerDetailsService.findOne({where: {
        accountId: job.order.accountId
      }});

      if(!customerDetails) {
        customerDetails = new CustomerDetails();
        customerDetails.invoiceSplitByOrderType = true;
        customerDetails.invoiceSplitByPO = true;
        customerDetails.invoiceSplitBySite = true;
        customerDetails.invoicePeriodId = 3;
        customerDetails.invoiceMethodId = 1;
      }

      // override from frontend
      if(data.extra.customerDetails) {
        customerDetails = data.extra.customerDetails;
      }
  
  
      if (customerDetails.invoiceSplitByOrderType) {
        split.push('orderType');
      }
  
      if (customerDetails.invoiceSplitByPO) {
        split.push('po');
      }
  
      if (customerDetails.invoiceSplitBySite) {
        split.push('site');
      }
  
      if (split.length === 0) {
        split = ['po', 'site', 'orderType'];
      }


      if(invoice === null) {
        invoice = await this.service.createInvoiceObject(job, customerDetails, ticketType, date, confirmation, invoiceNumber);
        invoice.id = jobs.bulk.length + -2;
        invoices.push(invoice);
      }

      
      // create invoices items for job and associate to invoice
      let newItems = await this.invoiceItemService.createInvoiceItemsForAdditionalChargesObjects(job, invoice);


      // Don't continue new extra charges
      if(newItems.length === 0) {
        return templateData;
      }

      // Set fake neg id
      newItems.forEach((item) => {
        item.invoiceId = invoice.id;
      })
    
      items = items.concat(newItems);
      
    }

    // generate invoice pdf


    let template = data.extra.type;

    const invoicingInfo = data.extra.pdfSettings;

    const showPods = data.extra.pods;

    if(template === 1) {
      template = data.extra.pdfSettings.headedInvoiceTemplate;
    } else if(template === 2) {
      template = data.extra.pdfSettings.unheadedInvoiceTemplate;
    }

    for(let i = 0; i < invoices.length; i++) {


    const invoice = invoices[i];

    const invoiceItems: any[] = items;


    invoiceItems.forEach((item) => {
      item.longDescription = item.longDescription.replace(/\n\r?/g, '<br />');
    });

    
    let subtotal = 0;
    let vatTotal = 0;
    let total = 0;
    let qtyTotal = 0;

    invoiceItems.forEach((item) => {
      item.total = item.qty * item.price;
      subtotal += item.total;
      qtyTotal += item.qty;
      if(invoiceItems[0].orderLine?.unit?.name !== 'Load') {
        item.qty =  item.qty.toFixed(2);
      };
	    item.total = item.total.toFixed(2);
    })

    const vatPercentage = <any>invoice.taxType.rate / 100;
    vatTotal = subtotal * vatPercentage;

    total = vatTotal + subtotal;

    // GET PODS

    const jobIds = invoiceItems.map((ii: InvoiceItem) => ii.jobId);

    let pods = [];


    if(jobIds.length === 0) {
      pods = [];
    } else {
      pods = await this.driverJobMovementService.find({where: {jobId: In(jobIds)}, relations: ["vehicle", "driver", "job","job.order","job.order.grade", "job.order.account","job.order.site", "job.order.orderLines", "job.order.orderLines.quoteLine", "job.order.orderLines.quoteLine.product"]})
    }

    const units = await this.unitService.find();


    const podData = [
    ]

      for(let podi = 0; podi < pods.length; podi++) {
        const pod: any = pods[podi];



        let historyData = await this.driverJobStatusDetailsService.getAllHistoryByJobId(pod.job.id);
        const jobMovements = await this.driverJobMovementService.find({
          where: {
            jobId: pod.job.id
          },
          select: ['id'],
        });
        
        let history = this.groupJobMovementHistory(historyData)[this.findPositionInMovements(jobMovements, pod.id)];
        
        if(!history) {
          history = [];
        }
        const imagesRaw = await this.documentsService.getDocumentsByEntityNameAndId("driver-job-movement", pod.id);
        const images = []

        // get all files from filesystem
        imagesRaw.forEach((document) => {
          const path = __dirname + "/../../files/"  + document.filename;
          const contents = fs.readFileSync(path, {encoding: 'base64'});
          images.push({
            filetype: document.filetype,
            filename:document.originalFilename,
            data: contents.toString()
          });
        })

        podData.push({
          pod: pod,
          order: pod.job.order,
          companyName: invoicingInfo.companyName,
          addressInfo: this.getCompanyAddress(invoicingInfo),
          companyLogo: invoicingInfo.companyLogo,
          service: this.getService(pod.job.order.orderLines),
          serviceUnit: this.getUnit(pod.job.order.orderLines, units),
          serviceAmount: pod.qty,
          siteAddress: this.getSiteAddress(pod.job.order),
          signatureDetails: this.getSignatureDetails(history),
          images: images,
          tipDetails: [],
          gpsCordsForSignature :history.filter(h => h.driverJobStatusId === 4)[0],
        })
    }


    let qtyTotalOutput:any = '';

    if(invoiceItems[0].orderLine?.unit.name === 'Load') {
      qtyTotalOutput = qtyTotal;
    } else {
      qtyTotalOutput = qtyTotal.toFixed(2);
    }

  
    templateData.datasets.push({
        customerAddress: this.getAddressDetails(invoice.account),
        invoiceNumber: data.extra.pdfSettings.invoicePrefix + invoice.id,
        invoiceDate: moment(invoice.invoiceDate).format('DD/MM/YYYY'),
        customerRef: invoice.account.accountRef,
        invoiceItems: invoiceItems,
        confirmation: invoice.confirmation,
        subtotal: subtotal.toFixed(2),
        vatTotal: vatTotal.toFixed(2),
        qtyTotal: qtyTotalOutput,
        total: total.toFixed(2),
        loadEx: invoice.loadEx,
        poNumber: invoice.poNumber,
        podsHTML: podData.length > 0 && showPods && !invoice.isAdditionalCharge ? await this.pdfService.createPDFUsingTemplate(data.extra.pdfSettings.podTemplate, '', {datasets: podData}, true) : '',
        vatRate: invoice.taxType.rate,
        invoiceSettings: data.extra.pdfSettings,
        showPods: showPods,
        tipMappings: [],
        jobTipMappings: {},
        tipChecks: false,
    });

  }

  return templateData;
  }

  @UseInterceptors(CrudRequestInterceptor)
  @Action('assignJob')
  @Post('assignJob')
  async assignJob(@ParsedRequest() req: CrudRequest, @Param() params, @Body() data: any) {
    const job = <Job>data;

    let invoiceId = -1;
    let split = []

    // get customer details
    const customerDetails = await this.customerDetailsService.findOne({where: {
      accountId: job.order.accountId
    }});


    if (customerDetails.invoiceSplitByOrderType) {
      split.push('orderType');
    }

    if (customerDetails.invoiceSplitByPO) {
      split.push('po');
    }

    if (customerDetails.invoiceSplitBySite) {
      split.push('site');
    }

    if (split.length === 0) {
      split = ['po', 'site', 'orderType', 'account'];
    }

 
    let invoice = await this.service.findAvaliableInvoice(job, split);

    if (invoice !== undefined) {
      invoiceId = invoice.id;
    } else {
      invoice = await this.service.createInvoiceFromJob(job, customerDetails);
    }

    // create invoices items for job and associate to invoice
    await this.invoiceItemService.createInvoiceItemsFromJob(job, invoice);
  }

  @UseInterceptors(CrudRequestInterceptor)
  @Action('pdf')
  @Post('pdf/:id')
  async pdf(@ParsedRequest() req: CrudRequest, @Param() params, @Body() data: any) {


    const invoice = await this.service.findOne(params.id, { relations: ['account', 'taxType'] });

    const invoiceItems: any[] = await this.invoiceItemService.getAllItemsByInvoiceExpanded(invoice.id);

    let showPods = data.pods;

    invoiceItems.forEach((item) => {
      item.longDescription = item.longDescription.replace(/\n\r?/g, '<br />');      
    });

    const invoicingInfo = data.invoicingInfo;


    let subtotal = 0;
    let vatTotal = 0;
    let total = 0;
    let qtyTotal = 0;

    // fallback for missing order lines
    if(invoiceItems[0].orderLine === undefined || invoiceItems[0].orderLine === null) {
      invoiceItems[0].orderLine = invoiceItems[0].job?.order?.orderLines[0];
    }

    invoiceItems.forEach((item) => {
      item.total = item.qty * item.price;
      subtotal += item.total;
      qtyTotal += item.qty;

      if(invoiceItems[0].orderLine?.unit.name !== 'Load') {
        item.qty =  item.qty.toFixed(2);
      }
	    item.total = item.total.toFixed(2);

      if(item.longDescription.indexOf('/') !== -1) {
        item.longDescription = this.truncateValueForTickets(item.longDescription).join('<br />');
      }
    })



    const vatPercentage = <any>invoice.taxType.rate / 100;
    vatTotal = subtotal * vatPercentage;

    total = vatTotal + subtotal;


    // GET PODS

    const jobIds = invoiceItems.map((ii: InvoiceItem) => ii.jobId);

    let pods = [];


    if(jobIds.length === 0) {
      pods = [];
    } else {
      pods = await this.driverJobMovementService.find({where: {jobId: In(jobIds)}, relations: ["vehicle", "driver", "job","job.order","job.order.account","job.order.site", "job.order.orderLines", "job.order.orderLines.quoteLine", "job.order.orderLines.quoteLine.product"]})
    }

    const units = await this.unitService.find();


    const podData = [
    ]

      for(let podi = 0; podi < pods.length; podi++) {
        const pod: any = pods[podi];



        const historyData = await this.driverJobStatusDetailsService.getAllHistoryByJobId(pod.job.id);

        
        const jobMovements = await this.driverJobMovementService.find({
          where: {
            jobId: pod.job.id
          },
          select: ['id'],
        });
        
        let history = this.groupJobMovementHistory(historyData)[this.findPositionInMovements(jobMovements, pod.id)];
        
        if(!history) {
          history = [];
        }
        
        const imagesRaw = await this.documentsService.getDocumentsByEntityNameAndId("driver-job-movement", pod.id);
        const images = []

        // get all files from filesystem
        imagesRaw.forEach((document) => {
          const path = __dirname + "/../../files/"  + document.filename;
          const contents = fs.readFileSync(path, {encoding: 'base64'});
          images.push({
            filetype: document.filetype,
            filename:document.originalFilename,
            data: contents.toString()
          });
        })

        
        podData.push({
          pod: pod,
          order: pod.job.order,
          companyName: invoicingInfo.companyName,
          addressInfo: this.getCompanyAddress(invoicingInfo),
          companyLogo: invoicingInfo.companyLogo,
          service: this.getService(pod.job.order.orderLines),
          serviceUnit: this.getUnit(pod.job.order.orderLines, units),
          serviceAmount: pod.qty,
          siteAddress: this.getSiteAddress(pod.job.order),
          signatureDetails: this.getSignatureDetails(history),
          images: images,
          tipDetails: [],
          gpsCordsForSignature :history.filter(h => h.driverJobStatusId === 4)[0],
        })
    }


    let qtyTotalOutput:any = '';

    if(invoiceItems[0].orderLine?.unit.name === 'Load') {
      qtyTotalOutput = qtyTotal;
    } else {
      qtyTotalOutput = qtyTotal.toFixed(2);
    }


    const templateData = {
      datasets: [{
        customerAddress: this.getAddressDetails(invoice.account),
        invoiceNumber: invoicingInfo.invoicePrefix + invoice.id,
        invoiceDate: moment(invoice.invoiceDate).format('DD/MM/YYYY'),
        customerRef: invoice.account.accountRef,
        confirmation: invoice.confirmation,
        invoiceItems: invoiceItems,
        subtotal: subtotal.toFixed(2),
        vatTotal: vatTotal.toFixed(2),
        qtyTotal: qtyTotalOutput,
        total: (Number(subtotal.toFixed(2)) + Number(vatTotal.toFixed(2))).toFixed(2),
        loadEx: invoice.loadEx,
        poNumber: invoice.poNumber,
        podsHTML: podData.length > 0 && showPods && !invoice.isAdditionalCharge ? await this.pdfService.createPDFUsingTemplate(invoicingInfo.podTemplate, '', {datasets: podData}, true) : '',
        vatRate: invoice.taxType.rate,
        invoiceSettings: invoicingInfo,
        tipMappings: [],
        jobTipMappings: {},
        tipChecks: false,
        
      }
      ]


    }
    await this.pdfService.createPDFUsingTemplate(invoicingInfo.headedInvoiceTemplate, __dirname + '/../../assets/invoice/' + invoice.id, templateData);

    return { fileName: '/invoice/' + invoice.id + '.pdf' };

  }

  @UseInterceptors(CrudRequestInterceptor)
  @Action('batchPdf')
  @Post('batchPdf/')
  async batchPdf(@ParsedRequest() req: CrudRequest, @Param() params, @Body() data: any) {

    const templateData = {datasets: []};

    let template = data.type;

    const invoicingInfo = data.pdfSettings;

    const showPods = data.pods;

    const showTickets = data.tipchecks;

    if(template === 1) {
      template = data.pdfSettings.headedInvoiceTemplate;
    } else if(template === 2) {
      template = data.pdfSettings.unheadedInvoiceTemplate;
    }

    for(let i = 0; i < data.invoiceIds.length; i++) {


    const invoice = await this.service.findOne(data.invoiceIds[i], { relations: ['account', 'taxType'] });

    const invoiceItems: any[] = await this.invoiceItemService.getAllItemsByInvoiceExpanded(invoice.id);


    invoiceItems.forEach((item) => {
      item.longDescription = item.longDescription.replace(/\n\r?/g, '<br />');
    });

    
    let subtotal = 0;
    let vatTotal = 0;
    let total = 0;
    let qtyTotal = 0;

    // fallback for missing order lines
    if(invoiceItems[0].orderLine === undefined || invoiceItems[0].orderLine === null) {
      invoiceItems[0].orderLine = invoiceItems[0].job?.order?.orderLines[0];
    }

    invoiceItems.forEach((item) => {
      item.total = item.qty * item.price;
      subtotal += item.total;
      qtyTotal += item.qty;
      item.descriptionParts = item.description.split('/');

    
      if(invoiceItems[0].orderLine?.unit?.name !== 'Load') {
        item.qty =  item.qty.toFixed(2);
      }
	    item.total = item.total.toFixed(2);

      if(item.longDescription.indexOf('/') !== -1) {
        item.longDescription = this.truncateValueForTickets(item.longDescription).join('<br />');
      }
    })




    const vatPercentage = <any>invoice.taxType.rate / 100;
    vatTotal = subtotal * vatPercentage;

    total = vatTotal + subtotal;

    // GET PODS

    const jobIds = invoiceItems.map((ii: InvoiceItem) => ii.jobId);




    let pods = [];


    if(jobIds.length === 0) {
      pods = [];
    } else {
      pods = await this.driverJobMovementService.find({where: {jobId: In(jobIds)}, relations: ["vehicle", "driver", "job","job.order","job.order.grade", "job.order.account","job.order.site", "job.order.orderLines", "job.order.orderLines.quoteLine", "job.order.orderLines.quoteLine.product"]})
    }

    const units = await this.unitService.find();


    const podData = [
    ]

      for(let podi = 0; podi < pods.length; podi++) {
        const pod: any = pods[podi];



        let historyData = await this.driverJobStatusDetailsService.getAllHistoryByJobId(pod.job.id);
        const jobMovements = await this.driverJobMovementService.find({
          where: {
            jobId: pod.job.id
          },
          select: ['id'],
        });
        
        let history = this.groupJobMovementHistory(historyData)[this.findPositionInMovements(jobMovements, pod.id)];
        
        if(!history) {
          history = [];
        }
        const imagesRaw = await this.documentsService.getDocumentsByEntityNameAndId("driver-job-movement", pod.id);
        const images = []

        // get all files from filesystem
        imagesRaw.forEach((document) => {
          const path = __dirname + "/../../files/"  + document.filename;
          const contents = fs.readFileSync(path, {encoding: 'base64'});
          images.push({
            filetype: document.filetype,
            filename:document.originalFilename,
            data: contents.toString()
          });
        })

        podData.push({
          pod: pod,
          order: pod.job.order,
          companyName: invoicingInfo.companyName,
          addressInfo: this.getCompanyAddress(invoicingInfo),
          companyLogo: invoicingInfo.companyLogo,
          service: this.getService(pod.job.order.orderLines),
          serviceUnit: this.getUnit(pod.job.order.orderLines, units),
          serviceAmount: pod.qty,
          siteAddress: this.getSiteAddress(pod.job.order),
          signatureDetails: this.getSignatureDetails(history),
          images: images,
          tipDetails: [],
          gpsCordsForSignature :history.filter(h => h.driverJobStatusId === 4)[0],
        })
    }


    let qtyTotalOutput:any = '';

    if(invoiceItems[0].orderLine?.unit?.name === 'Load') {
      qtyTotalOutput = qtyTotal;
    } else {
      qtyTotalOutput = qtyTotal.toFixed(2);
    }

    // get tip ticket checks
    const tipTickets = await this.tipTicketService.getAllByJobIds(jobIds);

    let tipMappings = [];
    // set if signed off or not.
    invoiceItems.forEach((invoiceItem) => {
      tipMappings = tipMappings.concat(this.generateTicketPairings(invoiceItem?.job.transportSignOffNotes, invoiceItem.jobId));
    });

    // Set signed on for mapping
    tipTickets.forEach((tipTicket: TipTicket) => {
      const tipMapping = tipMappings.filter(tm => tm.formatted === tipTicket.collectionTicketNumber)[0];


      if(tipMapping) {
          if(tipTicket.isSignedOff) {
            tipMapping.signedOff = true;
          }
      }
    });

    let jobTipMappings = [];

    tipMappings.forEach((mapping) => {
      if(!jobTipMappings[+mapping.jobId]) {
        jobTipMappings[+mapping.jobId] = [];
      }
      jobTipMappings[+mapping.jobId].push(mapping);
    })

    // return;

    templateData.datasets.push({
        customerAddress: this.getAddressDetails(invoice.account),
        invoiceNumber: data.pdfSettings.invoicePrefix + invoice.id,
        invoiceDate: moment(invoice.invoiceDate).format('DD/MM/YYYY'),
        customerRef: invoice.account.accountRef,
        invoiceItems: invoiceItems,
        confirmation: invoice.confirmation,
        subtotal: subtotal.toFixed(2),
        vatTotal: vatTotal.toFixed(2),
        qtyTotal: qtyTotalOutput,
        loadEx: invoice.loadEx,
        poNumber: invoice.poNumber,
        total: (Number(subtotal.toFixed(2)) + Number(vatTotal.toFixed(2))).toFixed(2),
        podsHTML: podData.length > 0 && showPods && !invoice.isAdditionalCharge ? await this.pdfService.createPDFUsingTemplate(data.pdfSettings.podTemplate, '', {datasets: podData}, true) : '',
        vatRate: invoice.taxType.rate,
        invoiceSettings: data.pdfSettings,
        showPods: showPods,
        tipMappings: tipMappings,
        jobTipMappings: jobTipMappings,
        tipChecks: showTickets,
    });

  }

  const batchId = uuidv4();
    await this.pdfService.createPDFUsingTemplate(template,  __dirname + '/../../assets/invoice/batch/' + data.pdfSettings.invoicePrefix + batchId, templateData);

    return { fileName: '/invoice/batch/' + data.pdfSettings.invoicePrefix + batchId+'.pdf' };

  }

  @UseInterceptors(CrudRequestInterceptor)
  @Post('rollback/:id')
  @Action('rollback')
  async rollback(@ParsedRequest() req: CrudRequest, @Param() params, @Body() data: any) {
    // Handle me with care
    // This whole method is distructive so be careful using it.
    
    const id = params['id'] ? params['id'] : -1;

    const invoice = await this.service.getInvoiceById(id);

    const items = await this.invoiceItemService.getAllItemsByInvoice(invoice.id);

    // rollback jobs and update.
    items.forEach((item: InvoiceItem) => {

      // Back to manager not signed off
      item.job.jobManagerSignOff = false;

      // Back to signed off and not invoiced on timeline
      item.job.jobStatusId = 4;
 
    });

    for(let i = 0; i < items.length; i++) {
      const item = items[i];

      // Update job
      await this.jobService.updateJob(item.job);
    }

    // nuke invoice items and invoice
    for(let i = 0; i < items.length; i++) {
      const item = items[i];

      // Update job
    await this.service.deleteInvoiceItem(item.id);
    }

    await this.service.deleteInvoice(invoice.id);


    // clean up email history
    await this.invoiceEmailLogService.deleteByInvoiceId(invoice.id);


    // reset auto increment counter
    let nextId = await this.service.nextId();


    if(!nextId) {
      nextId = 1;
    } else {
      nextId = nextId[0]['id']++;
    }

    await this.service.resetAutoIncrement(nextId);

    return 1;




  }

  async deleteAllHistoryItemForInvoiceId(invoiceId: number=-1) {
      await this.service.removeEmailHistoryItems(invoiceId);
  }

  @UseInterceptors(CrudRequestInterceptor)
  @Post('email/')
  @Action('email')
  async email(@ParsedRequest() req: CrudRequest, @Param() params, @Body() data: any) {
    const invoiceIds = data.invoiceIds;
    const toEmail = data.toEmail;
    const message = data.message;

    const attachments = [];
    let logs = [];

    for(let i = 0; i < invoiceIds.length; i++) {
      const id = invoiceIds[i];
      const params = {id: id};

      // create invoice log record
      const log = new InvoiceEmailLog();
      log.invoiceId = id;
      log.invoice = {id: id} as any;
      log.date = moment().format('YYYY-MM-DD');
      log.toEmail = toEmail;
      log.createdBy = -1; // might use this in future

      logs.push(log);

      // generate
      await this.pdf(req, params, data);

        attachments.push({
          filename:  id + '.pdf',
          content: fs.createReadStream( __dirname + '/../../assets/invoice/' + id + '.pdf')
      });
    }
    await this.mailService.sendEmailWithTemplate(toEmail, "Waste System | Invoices ("+ invoiceIds.join(',') + ")", 'generic',{message: message.replace(/(?:\r\n|\r|\n)/g, '<br>')}, attachments);

    // save logs if all is fine from here
    for(let i = 0; i < logs.length; i++) {
      let log = logs[i];

      await this.invoiceEmailLogService.createDTO(log);
    }

    return {};
  }


  private getAddressDetails(record): string {
    let address = record.name + '<br />';

    if (record.billingAddress1.trim() !== '') {
      address += record.billingAddress1 + '<br />';
    }

    if (record.billingAddress2.trim() !== '') {
      address += record.billingAddress2 + '<br />';
    }

    if (record.billingCity.trim() !== '') {
      address += record.billingCity + '<br />';
    }

    if (record.billingCountry.trim() !== '') {
      address += record.billingCountry + '<br />';
    }

    if (record.billingPostCode.trim() !== '') {
      address += record.billingPostCode;
    }

    return address;
  }

  private getSignatureDetails(history: any = []) {
    const result = history.filter(h => h.driverJobStatusId === 4)[0];
    
    if(!result) {
      return "Signature time was not captured"
    } else {
      return "Signature Signed at " + moment("10/05/1991 " + result.time).format('HH:mm:ss') + " on " + moment(result.date).format('DD/MM/YYYY');
    }
  }

  private getSiteAddress(order: any) {
    let address = "";

    if(order.site.shippingAddress1 !== "") {
      address += order.site.shippingAddress1 + "<br />";
    }  
    
    if(order.site.shippingAddress2 !== "") {
      address += order.site.shippingAddress2 + "<br />";
    }

    if(order.site.shippingCity !== "") {
      address += order.site.shippingCity + "<br />";
    } 
    
    if(order.site.shippingCountry !== "") {
      address += order.site.shippingCountry + "<br />";
    } 
    
    if(order.site.shippingPostCode !== "") {
      address += order.site.shippingPostCode + "<br />";
    }


    return address;
  }

  private getCompanyAddress(invoicing: any) {
    let address = "";

    if(invoicing.address1 !== "") {
      address += invoicing.address1 + "<br />";
    }

    if(invoicing.address2 !== "") {
      address += invoicing.address2 + "<br />";
    }

    if(invoicing.addressCity !== "") {
      address += invoicing.addressCountry + "<br />";
    }

    if(invoicing.addressCountry !== "") {
      address += invoicing.addressCountry + "<br />";
    }

    if(invoicing.addressPostcode !== "") {
      address += invoicing.addressPostcode + "<br />";
    }

    return address;
  }

  getService(orderLines: any) {
    const serviceType = '';

    let service = orderLines.filter(ol => ol.isPrimaryCharge)[0];

    if(!service) {
      service = orderLines[0];
    }

    return service.quoteLine ? service.quoteLine?.product?.name : service.name;
  }

  findPositionInMovements(movements: DriverJobMovement[], podId: number=-1): number {
    let index = 0;

    movements.forEach((movement, mindex) => {
      if(movement.id === podId) {
        index = mindex;
      }
    });

    return index;

  }

  groupJobMovementHistory(history: DriverJobStatusDetails[]=[]) {
    let groupedHistory = [];

    let head = 0;
    let previousIndex = -1;

    history.forEach((item) => {
      if(previousIndex > item.driverJobStatusId) {
        head++;
      }

      if(groupedHistory[head] === undefined) {
        groupedHistory[head] = [];
      }

      groupedHistory[head].push(item);
      previousIndex = item.driverJobStatusId;

    });

    return groupedHistory;
  }

  getUnit(orderLines: any, units:any) {
    const serviceType = '';

    let service = orderLines.filter(ol => ol.isPrimaryCharge)[0];

    if(!service) {
      service = orderLines[0];
    }

    const unit = units.filter(u => u.id === service.quoteLine?.product.unitId)[0];

    if(unit) {
      return unit.name;
    } else {
      // must be quick item
      const unitpl = units.filter(u => u.id === service.unitId)[0];
      return unitpl.name;
    }
  }

  generateTicketPairings(ticketData: string='', jobId: number =-1) {

    ticketData = !ticketData ? '' : ticketData;
    const tickets: string[]  = ticketData.split('/');

    let ticketMappings: any[] = [];

    if(tickets.length > 0) {
      let mainTicket:string = tickets[0];


      tickets.forEach((ticket: string, index) => {
        let formattedTicketNo: string = ticket;

        if(ticket.length > 3) {
          // It's a large set of numbers so must be a new seq
          mainTicket = ticket;
        }

        // tidy this up and make it context based.
        if(ticket.length === 3) {
          formattedTicketNo = mainTicket.substring(0, mainTicket.length - 3) + ticket;
        }

        if(ticket.length === 2) {
          formattedTicketNo = mainTicket.substring(0, mainTicket.length - 2) + ticket;
        }

        ticketMappings.push({
          formatted: formattedTicketNo,
          plain: ticket,
          signedOff: false,
          jobId: jobId,
        });
      })

      // clear up any enpty tickets
      ticketMappings = ticketMappings.filter(tt => tt.formatted.toString().trim() !== '' && tt.formatted !== <any>mainTicket.substring(0, mainTicket.length - 3));
      ticketMappings = ticketMappings.filter(tt => tt.formatted.toString().trim() !== '' && tt.formatted !== <any>mainTicket.substring(0, mainTicket.length - 2));

    }

    return ticketMappings;
    
    
  }

  truncateValueForTickets(data:string='') {


    if(data.indexOf('T/T') !== -1 || data.length <= 50) {
      return [data];
    }

    let maxChars = 50;
    let sep = '/';
    let newLines = [];
    let lineIndex = 0;

    let lineParts = data.split('/');

    lineParts.forEach((ticket) => {
      if(!newLines[lineIndex]) {
        newLines[lineIndex] = '';
      }

      if((ticket.length + sep.length + newLines[lineIndex].length > maxChars)) {
        lineIndex++;
      }

      if(!newLines[lineIndex]) {
        newLines[lineIndex] = '';
      }
      newLines[lineIndex] += ticket + '/';
    });

    // remove last index slash
    if(newLines[newLines.length -1].endsWith(sep)) {
      newLines[newLines.length -1] = newLines[newLines.length - 1].substring(0, newLines[newLines.length -1].length-1);
    }

    return newLines;
  }
}
