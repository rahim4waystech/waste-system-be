
import { Documents } from "./documents.entity";
import { Crud, CrudController, ParsedRequest, CrudRequest, Action } from "@nestjsx/crud";
import { Controller, Post, UseInterceptors, UploadedFile, Param, Body, Get, Header, HttpCode, HttpStatus, Res, Req, Response } from "@nestjs/common";
import { DocumentsService } from "./documents.service";
import { FileInterceptor } from "@nestjs/platform-express/multer";

import * as fs from 'fs';
/**
 * This file was generated by Four Ways Technology
 *
 * On Tue Dec 15 2020 10:10:32 GMT+0000 (Greenwich Mean Time)
 */
@Crud({
    model: {
      type: Documents
    }
  })
  @Controller('documents')
  export class DocumentsController implements CrudController<Documents> {
    constructor(public service: DocumentsService) {}

    @Post('/upload/app/:type/:entityId')
    async uploadAppFile(@UploadedFile() file, @Param('type') type: string, @Param('entityId') entityId: number, @ParsedRequest() req: CrudRequest, @Body() data: any) {
      let fileData = data.filedata;

      let uuid = this.generateGuid();

      const doc = new Documents();
      doc.id = null;
      doc.filetype = data.mimetype;
      doc.type = type;
      doc.originalFilename = data.originalname;
      doc.filename = uuid;
      doc.entity = type;
      doc.entityId = entityId;

      const imageBuffer = new Buffer(fileData, "base64");

      fs.writeFileSync(__dirname + "/../../files/" + uuid, imageBuffer);


    return await this.service.createUsingDTO(doc);
    }


    @Post('upload/:type/:entityId')
    async uploadFile(@Param('type') type: string, @Param('entityId') entityId: string, @ParsedRequest() req: CrudRequest, @Body() data: any) {
      const doc = new Documents();
      let uuid = this.generateGuid();
      let fileData = data.fileData;

      doc.id = null;
      doc.filetype = data.mimeType;
      doc.type = type;
      doc.originalFilename = data.originalFilename;
      doc.filename = uuid;
      doc.entity = type;
      doc.entityId = +entityId;

      const imageBuffer = new Buffer(fileData, "base64");
      fs.writeFileSync(__dirname + "/../../files/" + uuid, imageBuffer);

      await this.service.createUsingDTO(doc);

      return doc;
    }

    @Get('viewdoc/:id')
    @HttpCode(HttpStatus.OK)
    async viewDocument(@Param('id') id:number, @Response() res: any){
      const document = await this.service.getDocumentById(id);

      res.download(__dirname + "/../../files/"  + document[0].filename, document[0].originalFilename);
    }

    @Get('viewpdf/:id')
    @HttpCode(HttpStatus.OK)
    async viewPdf(@Param('id') id:number, @Response() res: any){
      const document = await this.service.getDocumentById(id);
      const path = __dirname + "/../../files/"  + document[0].filename;
      var stream = fs.createReadStream(path);
      var filename = document[0].originalFilename;
      // Be careful of special characters
      filename = encodeURIComponent(filename);
      // Ideally this should strip them
      res.setHeader('Content-disposition', 'inline; filename="' + filename + '"');
      res.setHeader('Content-type', 'application/pdf');
      stream.pipe(res);
    }

    @Get('getimage/:id')
    @HttpCode(HttpStatus.OK)
    async getImage(@Param('id') id:number){
      const document = await this.service.getDocumentById(id);
      const path = __dirname + "/../../files/"  + document[0].filename;
      const contents = fs.readFileSync(path, {encoding: 'base64'});
      const stuff = {
        filetype: document[0].filetype,
        filename:document[0].originalFilename,
        data: contents.toString()
      }
      return stuff;
    }

     generateGuid() {
      var result, i, j;
      result = '';
      for(j=0; j<32; j++) {
        if( j == 8 || j == 12 || j == 16 || j == 20)
          result = result + '-';
        i = Math.floor(Math.random()*16).toString(16).toUpperCase();
        result = result + i;
      }
      return result;
    }
  }
