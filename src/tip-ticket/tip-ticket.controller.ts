
import { TipTicket } from "./tip-ticket.entity";
import { Crud, CrudController } from "@nestjsx/crud";
import { Body, Controller, Get, Param, Post, Query } from "@nestjs/common";
import { TipTicketService } from "./tip-ticket.service";
import { Job } from "src/job/job.entity";
import { Order } from "src/order/order.entity";
import { TipTicketGeneratorService } from "./tip-ticket-generator.service";
import { JobService } from "src/job/job.service";
/**
 * This file was generated by Four Ways Technology
 *
 * On Thu Jul 01 2021 12:32:38 GMT+0100 (British Summer Time)
 */
@Crud({
    model: {
      type: TipTicket
    },
    query: {
      join: {
        unit: {
          eager: false,
        },
        job: {
          eager: false,
        },
        "job.order": {
          eager: false,
        },
        "order.account": {
          eager: false,
          alias: 'jao',
        }
      }
    }
  })
  @Controller('tip-ticket')
  export class TipTicketController implements CrudController<TipTicket> {
    constructor(public service: TipTicketService,
      private jobService: JobService,
      private tipTicketGeneratorService: TipTicketGeneratorService) {}
    @Get('grid')
    async getTipTicketGrid(@Query('page') page: number = 1, @Query('limit') limit: number = 10, @Query('filters') filters: string='') {
      
      let filtersJson = {};

      if(!filters || filters === '') {
        filtersJson = {};
      } else {
        filtersJson = JSON.parse(filters);
      }
      
      return this.service.getTipTicketGrid(+page, +limit, filtersJson);
    }

    @Post('deleteAllByJobId/:jobId')
    deleteAllByJobId(@Param() params) {

      if(!params['jobId']) {
        throw new Error('You must supply an id for deleteAllByJobId');
      }

      this.service.deleteAllForJobId(params['jobId']);
      return [];
    }


    @Post('regen-tickets')
    async reGenTickets(@Body() data: any) {

      //  get order from post body
      let order: Order = <Order>data;

      let tickets: TipTicket[] = [];
      let orderId: number = order.id;

      // get order details check if tip fee if not stop.
      if(order.tipFee <= 0) {
        return -1;
      }

      // get all job ids for order
      let jobs: any[] = await this.jobService.getAllJobsByOrderId(orderId);

      // check if tickets exist for job and signed off
      let regenJobs: Job[] = jobs.filter(j => j.jobSignOffStatusId !== -1 && j.jobStatusId !== 1 && j.jobStatusId !== 3);

      for(let i = 0; i < jobs.length; i++) {

        let job = jobs[i];
        // only create tip tickets if the jobs don't have tip tickets already.
        let currentTickets: TipTicket[] = [];
        currentTickets = await this.service.getAllByJobIds([job.id]);

        // skip if already has tickets or job is not signed off
        if(currentTickets.length > 0 || !job.jobManagerSignOff) {
          continue;
        }

        // break up ticket number and do one ticket per ticket number
        let tipTickets: TipTicket[] = this.tipTicketGeneratorService.generateTipTicketsFromNotes(job);
        tickets = tickets.concat(tipTickets);
      }

      // if not create all the tickets
      for(let i = 0; i < tickets.length; i++) {
        await this.service.saveDTO(tickets[i]);
      }

      return 1;
    }
  }