
import { InvoiceItem } from "./invoice-item.entity";
import { Injectable } from "@nestjs/common";
import { InjectRepository } from "@nestjs/typeorm";

import { TypeOrmCrudService } from "@nestjsx/crud-typeorm";
import { Job } from "src/job/job.entity";
import { OrderLineService } from "src/order-line/order-line.service";
import { OrderLine } from "src/order-line/order-line.entity";
import { Invoice } from "src/invoice/invoice.entity";
import { CreditLimitService } from "src/credit-limit/credit-limit.service";
import { NominalCodeService } from "src/nominal-code/nominal-code.service";
import { DriverJobMovement } from "src/driver-job-movement/driver-job-movement.entity";
import { YardTrade } from "src/yard-trade/yard-trade.entity";
import { YardTradePricing } from "src/yard-trade-pricing/yard-trade-pricing.entity";
import { JobService } from "src/job/job.service";

/**
 * This file was generated by Four Ways Technology
 * 
 * On Wed Sep 23 2020 15:37:53 GMT+0100 (British Summer Time)
 */
@Injectable()
export class InvoiceItemService extends TypeOrmCrudService<InvoiceItem> {
  constructor(@InjectRepository(InvoiceItem) repo,
  private creditLimitService: CreditLimitService,
  private jobService: JobService,
  private nominalCodeService: NominalCodeService,
  private orderLineService: OrderLineService) {
    super(repo);
  }

  async getTicketMatches(ticketNo: string) {
    const query = this.repo.createQueryBuilder();

    const matches = await this.jobService.findByTicketNo(ticketNo);
    console.log(matches);
    console.log( await this.repo.query(`
    SELECT order.id as orderId, job.transportSignOffNotes as transportSignOffNotes, vehicle.registration as registration, job.id as jobId,job.date as jobDate, invoice.id as invoiceId, job.transportSignOffNotes as tickets, a.name as accountName, b.name as siteName, c.name as tipSiteName FROM invoice_item
    inner join \`job\` on job.id = invoice_item.jobId
    inner join invoice on invoice.id = invoice_item.invoiceId
    inner join \`order\` on  \`order\`.id = job.orderId
    inner join account a on a.id = order.accountId
    inner join account b on b.id = order.siteId
    inner join account c on c.id = order.tipSiteId
    inner join job_assignment on job_assignment.id = job.jobAssignmentId
    left join vehicle on vehicle.id = job_assignment.vehicleId
    where jobId IN (?)
  `, [matches.map(m => m.id)]));
    return await this.repo.query(`
      SELECT order.id as orderId, job.transportSignOffNotes as transportSignOffNotes, vehicle.registration as registration, job.id as jobId,job.date as jobDate, invoice.id as invoiceId, job.transportSignOffNotes as tickets, a.name as accountName, b.name as siteName, c.name as tipSiteName FROM invoice_item
      inner join \`job\` on job.id = invoice_item.jobId
      inner join invoice on invoice.id = invoice_item.invoiceId
      inner join \`order\` on  \`order\`.id = job.orderId
      inner join account a on a.id = order.accountId
      inner join account b on b.id = order.siteId
      inner join account c on c.id = order.tipSiteId
      inner join job_assignment on job_assignment.id = job.jobAssignmentId
      left join vehicle on vehicle.id = job_assignment.vehicleId
      where jobId IN (?)
    `, [matches.map(m => m.id)]);


    return await query.getMany();
  }

  async getAllItemsByInvoice(invoiceId: number) {
    if(!invoiceId || invoiceId === -1) {
      throw new Error('InvoiceItemService: getAllItemsByInvoice must be a valid invoiceid');
    } 

    return await this.repo.find({ where: { invoiceId: invoiceId }, relations: ["job", "orderLine.order", "orderLine","orderLine.quoteLine", "orderLine.quoteLine.product", "job.jobAssignment", "job.jobAssignment.vehicle", "orderLine.unit"] });
  }

  async getAllItemsByInvoiceExpanded(invoiceId: number) {
    if(!invoiceId || invoiceId === -1) {
      throw new Error('InvoiceItemService: getAllItemsByInvoice must be a valid invoiceid');
    } 

    return await this.repo.find({ where: { invoiceId: invoiceId }, relations: ["job", "job.order", "job.order.orderLines", "job.order.orderLines.unit","orderLine.order", "orderLine","orderLine.quoteLine", "orderLine.quoteLine.product", "job.jobAssignment", "job.jobAssignment.vehicle", "orderLine.unit"] });
  }


  async getInvoiceItemById(invoiceItemId: number) {
    if(!invoiceItemId || invoiceItemId === -1) {
      throw new Error('InvoiceItemService: getInvoiceItemById must be a valid invoiceItemId');
    } 

    return await this.repo.find({ where: { id: invoiceItemId }, relations: ["job", "orderLine.order", "orderLine","orderLine.quoteLine", "orderLine.quoteLine.product", "job.jobAssignment", "job.jobAssignment.vehicle", "orderLine.unit"] });
  }

  async createInvoiceAdditionalChargeItemsFromJob(job: Job, invoice: Invoice, orderLines: OrderLine[]) {

    // Only for ynd 
    if(orderLines.length > 1) {
      // Only additional charge
      orderLines = [orderLines[1]];
    }

    let driverJobMovements: DriverJobMovement[] = await this.getAllPodsByJobId(job.id);
    let units = await this.getUnits();
    let primaryChargeId = 0;

    let ticketAmount = 0;
    let ticketNos = [];

    driverJobMovements.forEach((movement:DriverJobMovement) => {
      ticketAmount += !movement.qty || movement.qty === 0? 1 : movement.qty; 
      ticketNos.push(movement.id);
    })

    const primaryCharge = orderLines.filter(ol => ol.isPrimaryCharge)[0];

    let nominalCodes = await this.nominalCodeService.getAll();
    if(primaryCharge !== undefined) {
      primaryChargeId = primaryCharge.id;
    } else {
      primaryChargeId = orderLines[0].id;
    }


    const nominalCodeRecord = nominalCodes.filter(no => no.orderTypeId === job.order.orderTypeId)[0];


    let total = 0;
    for(let i =0; i < orderLines.length; i++) {
      const line = orderLines[i];
      const invoiceitem: InvoiceItem = new InvoiceItem();
      invoiceitem.invoiceId = invoice.id;
      invoiceitem.invoice = invoice;
      invoiceitem.job = job;
      invoiceitem.jobId = job.id;
      invoiceitem.orderLine = line;
      invoiceitem.orderLineId = line.id;

      if(nominalCodeRecord) {
        invoiceitem.nominalCode = nominalCodeRecord.code;
      } else {
        // no nominal found
        invoiceitem.nominalCode = '0';
      }

      invoiceitem.date = job.date;

      if(i === primaryChargeId) {
        let qty = 0;

        if(job.weight > 0) {
          qty = job.weight;
        } else {
          qty = job.qty;
        }

        total += orderLines[i].qty * orderLines[i].price;

        invoiceitem.qty = qty;
        invoiceitem.price = line.price;

        let description = '';

        description = ` JOB Number: ${job.id} - ${job.order.grade.name}(${job.order.grade.ewcCodes}) ${job.order.containerSizeType.size} yard(s) ${job.order.containerType.name} ${job.order.skipOrderType.name}`

        invoiceitem.longDescription = description;
        invoiceitem.description = description;

      } else {

        let productDescription = '';

        if(line.quoteLine) {
          productDescription = line.quoteLine.product.displayName && line.quoteLine.product.displayName !== '' ? line.quoteLine.product.displayName : line.quoteLine.product.name;
        }

        
      
        invoiceitem.price = line.price;

        const vehicleReg = job.jobAssignment.vehicleId !== -1 ? job.jobAssignment.vehicle.registration : "";

        // first item or primary charge
        if((i === 0 || line.isPrimaryCharge) && job.order.orderTypeId !== 1) { 

          let unit = units.filter(u => u.id === line.unitId)[0];

          if(!unit) {
            unit = {id: -1, name: 'N/A'};
          }

          // allow for price to be override based on what's set in job
          invoiceitem.price = line.price;
          invoiceitem.qty = line.qty;
          invoiceitem.description = "JOB NO: " + job.id + ' ' + line.name;
          invoiceitem.longDescription = "JOB NO: " + job.id + ' ' + line.name;
        } else if((i === 0 || line.isPrimaryCharge) && job.order.orderTypeId === 1) {
          // it's skips
          invoiceitem.qty = job.qty;
          invoiceitem.description = "JOB NO: " + job.id + ' ' + job.order.containerSizeType.size + ' Yard ' + job.order.containerType.name + ' - ' + job.order.grade.name + ' - ' + job.order.skipOrderType.name;
          invoiceitem.longDescription = invoiceitem.description; 
          } else {
          invoiceitem.qty = line.qty;
          invoiceitem.description = line.quoteLine ? productDescription :line.name;
          invoiceitem.longDescription = invoiceitem.description;
        }
      }

      await this.repo.save(invoiceitem);

    }

    // update credit limits 
    const creditLimit = await this.creditLimitService.getByAccountId(job.order.accountId);

    if(creditLimit) {
      creditLimit.usedCredit -= total;

      if(creditLimit.usedCredit <= 0) {
        creditLimit.usedCredit = 0;
      }

      await this.creditLimitService.saveCreditLimit(creditLimit);
    }
  }


  async createInvoiceItemsFromJob(job: Job, invoice: Invoice) {
    // get orderlines for job.
    let orderLines: OrderLine[] = await this.orderLineService.getAllOrderLinesForOrderId(job.order.id);

    // Only for ynd 
    if(orderLines.length > 1) {
      // Don't process additional charges.
      orderLines = [orderLines[0]];
    }

    let driverJobMovements: DriverJobMovement[] = await this.getAllPodsByJobId(job.id);
    let units = await this.getUnits();
    let primaryChargeId = 0;

    let ticketAmount = 0;
    let ticketNos = [];

    driverJobMovements.forEach((movement:DriverJobMovement) => {
      ticketAmount += !movement.qty || movement.qty === 0? 1 : movement.qty; 
      ticketNos.push(movement.id);
    })

    const primaryCharge = orderLines.filter(ol => ol.isPrimaryCharge)[0];

    let nominalCodes = await this.nominalCodeService.getAll();
    if(primaryCharge !== undefined) {
      primaryChargeId = primaryCharge.id;
    } else {
      primaryChargeId = orderLines[0].id;
    }


    const nominalCodeRecord = nominalCodes.filter(no => no.orderTypeId === job.order.orderTypeId)[0];


    let total = 0;
    for(let i =0; i < orderLines.length; i++) {
      const line = orderLines[i];
      const invoiceitem: InvoiceItem = new InvoiceItem();
      invoiceitem.invoiceId = invoice.id;
      invoiceitem.invoice = invoice;
      invoiceitem.job = job;
      invoiceitem.jobId = job.id;
      invoiceitem.orderLine = line;
      invoiceitem.orderLineId = line.id;

      if(nominalCodeRecord) {
        invoiceitem.nominalCode = nominalCodeRecord.code;
      } else {
        // no nominal found
        invoiceitem.nominalCode = '0';
      }

      invoiceitem.date = job.date;

      if(i === primaryChargeId) {
        let qty = 0;

        if(job.weight > 0) {
          qty = job.weight;
        } else {
          qty = job.qty;
        }

        total += orderLines[i].qty * orderLines[i].price;

        invoiceitem.qty = qty;
        invoiceitem.price = line.price;

        let description = '';

        description = ` JOB Number: ${job.id} - ${job.order.grade.name}(${job.order.grade.ewcCodes}) ${job.order.containerSizeType.size} yard(s) ${job.order.containerType.name} ${job.order.skipOrderType.name}`

        invoiceitem.longDescription = description;
        invoiceitem.description = description;

      } else {

        let productDescription = '';

        if(line.quoteLine) {
          productDescription = line.quoteLine.product.displayName && line.quoteLine.product.displayName !== '' ? line.quoteLine.product.displayName : line.quoteLine.product.name;
        }

        
      
        invoiceitem.price = line.price;

        const vehicleReg = job.jobAssignment.vehicleId !== -1 ? job.jobAssignment.vehicle.registration : "";

        // first item or primary charge
        if((i === 0 || line.isPrimaryCharge) && job.order.orderTypeId !== 1) { 

          let unit = units.filter(u => u.id === line.unitId)[0];

          if(!unit) {
            unit = {id: -1, name: 'N/A'};
          }

          // allow for price to be override based on what's set in job
          invoiceitem.price = job.overridePrice ? job.newPrice : line.price;
          invoiceitem.qty = job.qty;
          invoiceitem.description = line.quoteLine ? productDescription :line.name;
          invoiceitem.longDescription = job.transportSignOffNotes + " " + (invoice.confirmation ? invoiceitem.description : '');
        } else if((i === 0 || line.isPrimaryCharge) && job.order.orderTypeId === 1) {
          // it's skips
          invoiceitem.qty = job.qty;
          invoiceitem.description = "JOB NO: " + job.id + ' ' + job.order.containerSizeType.size + ' Yard ' + job.order.containerType.name + ' - ' + job.order.grade.name + ' - ' + job.order.skipOrderType.name;
          invoiceitem.longDescription = invoiceitem.description; 
         } else {
          invoiceitem.qty = line.qty;
          invoiceitem.description = line.quoteLine ? productDescription :line.name;
          invoiceitem.longDescription = invoiceitem.description;
        }
      }

      await this.repo.save(invoiceitem);

    }

    // update credit limits 
    const creditLimit = await this.creditLimitService.getByAccountId(job.order.accountId);

    if(creditLimit) {
      creditLimit.usedCredit -= total;

      if(creditLimit.usedCredit <= 0) {
        creditLimit.usedCredit = 0;
      }

      await this.creditLimitService.saveCreditLimit(creditLimit);
    }
  }

  async createInvoiceItemsFromYardTrade(yardTrade: YardTrade, invoice: Invoice) {
    const pricing: YardTradePricing[] = yardTrade.yardTradePricing;
    
    let items = [];

    for(let i = 0; i < pricing.length; i++) {

      const priceItem = pricing[i];
      const item = new InvoiceItem();
      item.nominalCode = '0'; //todo nominal for yard trade
      item.price = priceItem.price;
      item.qty = priceItem.qty;
      item.longDescription = priceItem.name;
      item.description = priceItem.name;
      item.job = {id: -1} as any;
      item.jobId = -1;
      item.orderLine = {id: -1} as any;
      item.orderLineId = -1;
      item.date = yardTrade.date;
      item.invoice = {id: invoice.id} as any;
      item.invoiceId = invoice.id;

      await this.repo.save(item);
    }

  }

  async createInvoiceItemsFromJobObjects(job: Job, invoice: Invoice) {
    // get orderlines for job.
    let orderLines: OrderLine[] = await this.orderLineService.getAllOrderLinesForOrderId(job.order.id);

    // Don't do additional charges
    if(orderLines.length > 1) {
      orderLines = [orderLines[0]]; 
    }

    let items = [];

    let driverJobMovements: DriverJobMovement[] = await this.getAllPodsByJobId(job.id);
    let units = await this.getUnits();
    let primaryChargeId = 0;

    let ticketAmount = 0;
    let ticketNos = [];

    driverJobMovements.forEach((movement:DriverJobMovement) => {
      ticketAmount += !movement.qty || movement.qty === 0? 1 : movement.qty; 
      ticketNos.push(movement.id);
    })

    const primaryCharge = orderLines.filter(ol => ol.isPrimaryCharge)[0];

    let nominalCodes = await this.nominalCodeService.getAll();
    if(primaryCharge !== undefined) {
      primaryChargeId = primaryCharge.id;
    } else {
      primaryChargeId = orderLines[0].id;
    }


    const nominalCodeRecord = nominalCodes.filter(no => no.orderTypeId === job.order.orderTypeId)[0];


    let total = 0;
    for(let i =0; i < orderLines.length; i++) {
      
      const line = orderLines[i];
      const invoiceitem: InvoiceItem = new InvoiceItem();
      invoiceitem.invoiceId = invoice.id;
      invoiceitem.invoice = invoice;
      invoiceitem.job = job;
      invoiceitem.jobId = job.id;
      invoiceitem.orderLine = line;
      invoiceitem.orderLineId = line.id;

      if(nominalCodeRecord) {
        invoiceitem.nominalCode = nominalCodeRecord.code;
      } else {
        // no nominal found
        invoiceitem.nominalCode = '0';
      }

      invoiceitem.date = job.date;

      if(i === primaryChargeId) {
        let qty = 0;

        if(job.weight > 0) {
          qty = job.weight;
        } else {
          qty = job.qty;
        }

        total += orderLines[i].qty * orderLines[i].price;

        invoiceitem.qty = qty;
        invoiceitem.price = line.price;

        let description = '';

        description = ` JOB Number: ${job.id} - ${job.order.grade.name}(${job.order.grade.ewcCodes}) ${job.order.containerSizeType.size} yard(s) ${job.order.containerType.name} ${job.order.skipOrderType.name}`

        invoiceitem.longDescription = description;
        invoiceitem.description = description;

      } else {

        let productDescription = '';

        if(line.quoteLine) {
          productDescription = line.quoteLine.product.displayName && line.quoteLine.product.displayName !== '' ? line.quoteLine.product.displayName : line.quoteLine.product.name;
        }

        
      
        invoiceitem.price = line.price;

        const vehicleReg = job.jobAssignment.vehicleId !== -1 ? job.jobAssignment.vehicle.registration : "";

        // first item or primary charge
        if(i === 0 || line.isPrimaryCharge && job.order.orderTypeId !== 1) { 

          let unit = units.filter(u => u.id === line.unitId)[0];

          if(!unit) {
            unit = {id: -1, name: 'N/A'};
          }

          invoiceitem.qty = job.qty;
          invoiceitem.description = line.quoteLine ? productDescription :line.name;
          invoiceitem.longDescription = job.transportSignOffNotes + " " + (invoice.confirmation ? invoiceitem.description : '');
        } else if(i === 0 || line.isPrimaryCharge && job.order.orderTypeId === 1) {
          // it's skips
          invoiceitem.qty = job.qty;
          invoiceitem.description = "JOB NO: " + job.id + ' ' + job.order.containerSizeType.size + ' Yard ' + job.order.containerType.name + ' - ' + job.order.grade.name + ' - ' + job.order.skipOrderType.name;
          invoiceitem.longDescription = invoiceitem.description; 
         } else {
          invoiceitem.qty = line.qty;
          invoiceitem.description = line.quoteLine ? productDescription :line.name;
          invoiceitem.longDescription = invoiceitem.description;
        }
      }
      items.push(invoiceitem);

      }


    return items;

  }

  async createInvoiceItemsForAdditionalChargesObjects(job: Job, invoice: Invoice) {
    // get orderlines for job.
    let orderLines: OrderLine[] = await this.orderLineService.getAllOrderLinesForOrderId(job.order.id);

    // Don't do additional charges
    if(orderLines.length > 1) {
      orderLines = [orderLines[1]]; 
    } else {
      return [];
    }

    let items = [];

    let driverJobMovements: DriverJobMovement[] = await this.getAllPodsByJobId(job.id);
    let units = await this.getUnits();
    let primaryChargeId = 0;

    let ticketAmount = 0;
    let ticketNos = [];

    driverJobMovements.forEach((movement:DriverJobMovement) => {
      ticketAmount += !movement.qty || movement.qty === 0? 1 : movement.qty; 
      ticketNos.push(movement.id);
    })

    const primaryCharge = orderLines.filter(ol => ol.isPrimaryCharge)[0];

    let nominalCodes = await this.nominalCodeService.getAll();
    if(primaryCharge !== undefined) {
      primaryChargeId = primaryCharge.id;
    } else {
      primaryChargeId = orderLines[0].id;
    }


    const nominalCodeRecord = nominalCodes.filter(no => no.orderTypeId === job.order.orderTypeId)[0];


    let total = 0;
    for(let i =0; i < orderLines.length; i++) {
      
      const line = orderLines[i];
      const invoiceitem: InvoiceItem = new InvoiceItem();
      invoiceitem.invoiceId = invoice.id;
      invoiceitem.invoice = invoice;
      invoiceitem.job = job;
      invoiceitem.jobId = job.id;
      invoiceitem.orderLine = line;
      invoiceitem.orderLineId = line.id;

      if(nominalCodeRecord) {
        invoiceitem.nominalCode = nominalCodeRecord.code;
      } else {
        // no nominal found
        invoiceitem.nominalCode = '0';
      }

      invoiceitem.date = job.date;

      if(i === primaryChargeId) {
        let qty = 0;

        if(job.weight > 0) {
          qty = job.weight;
        } else {
          qty = job.qty;
        }

        total += orderLines[i].qty * orderLines[i].price;

        invoiceitem.qty = qty;
        invoiceitem.price = line.price;

        let description = '';

        description = ` JOB Number: ${job.id} - ${job.order.grade.name}(${job.order.grade.ewcCodes}) ${job.order.containerSizeType.size} yard(s) ${job.order.containerType.name} ${job.order.skipOrderType.name}`

        invoiceitem.longDescription = description;
        invoiceitem.description = description;

      } else {

        let productDescription = '';

        if(line.quoteLine) {
          productDescription = line.quoteLine.product.displayName && line.quoteLine.product.displayName !== '' ? line.quoteLine.product.displayName : line.quoteLine.product.name;
        }

        
      
        invoiceitem.price = line.price;

        const vehicleReg = job.jobAssignment.vehicleId !== -1 ? job.jobAssignment.vehicle.registration : "";

        // first item or primary charge
        if(i === 0 || line.isPrimaryCharge && job.order.orderTypeId !== 1) { 

          let unit = units.filter(u => u.id === line.unitId)[0];

          if(!unit) {
            unit = {id: -1, name: 'N/A'};
          }

          invoiceitem.qty = line.qty;
          invoiceitem.description = "JOB NO: " + job.id + ' ' + line.name;
          invoiceitem.longDescription = "JOB NO: " + job.id + ' ' + line.name;
        } else if(i === 0 || line.isPrimaryCharge && job.order.orderTypeId === 1) {
          // it's skips
          invoiceitem.qty = job.qty;
          invoiceitem.description = "JOB NO: " + job.id + ' ' + job.order.containerSizeType.size + ' Yard ' + job.order.containerType.name + ' - ' + job.order.grade.name + ' - ' + job.order.skipOrderType.name;
          invoiceitem.longDescription = invoiceitem.description; 
         } else {
          invoiceitem.qty = line.qty;
          invoiceitem.description = line.quoteLine ? productDescription :line.name;
          invoiceitem.longDescription = invoiceitem.description;
        }
      }
      items.push(invoiceitem);

      }


    return items;

  }



  async getAllPodsByJobId(jobId:number=-1) {
    return await this.repo.manager.query("SELECT * FROM driver_job_movement where jobId = ?", [jobId]);
  }

  async getUnits() {
    return await this.repo.manager.query("SELECT * FROM unit");
  }


}
