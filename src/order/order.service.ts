
import { Order } from "./order.entity";
import { Injectable } from "@nestjs/common";
import { InjectRepository } from "@nestjs/typeorm";

import { TypeOrmCrudService } from "@nestjsx/crud-typeorm";
import { OrderStatusHistory } from "src/order-status-history/order-status-history.entity";
import { OrderStatusHistoryService } from "src/order-status-history/order-status-history.service";
import { MailService } from "src/core/mail.service";
import { OrderLineService } from "src/order-line/order-line.service";
import { OrderLine } from "src/order-line/order-line.entity";

/**
 * This file was generated by Four Ways Technology
 * 
 * On Mon Aug 10 2020 15:40:35 GMT+0100 (British Summer Time)
 */
@Injectable()
export class OrderService extends TypeOrmCrudService<Order> {
  constructor(@InjectRepository(Order) repo,
  private orderLineService: OrderLineService,
  private orderHistoryStatusService: OrderStatusHistoryService,
  private mailService:MailService) {
     
    super(repo);
  }

  async getOrdersForShredding(date:string, page:number=1, amount:number=10, search: string='', sort:string='time') {


    let orderBySQL = '';

    if(sort === 'time') {
      orderBySQL = ' ORDER BY order.time asc';
    }

    if(sort === "account") {
      orderBySQL = ' ORDER BY account.name desc';
    }

    if(sort === "po-number") {
      orderBySQL = ' ORDER BY order.poNumber asc';
    }

    const offset = (page-1) * amount;
    const params: any[] = [date, date, date, date,date,date,date,date,date,date,date];


    let searchSQL = '';
    if(search !== '') {
      searchSQL = ' and account.name LIKE ?';
      params.push('%' + search + '%');
    }

    params.push(offset);
 
    const results = await this.repo.query(`
SELECT \`order\`.id FROM \`order\`
LEFT JOIN order_type on order_type.id = \`order\`.orderTypeId
LEFT JOIN account on account.id = \`order\`.accountId
-- Standard query for date range
where \`order\`.id in (
	select id from \`order\`
    where \`order\`.orderStatusId = 2 and
    (\`order\`.contractId is null or \`order\`.contractId = -1)
	and \`order\`.date = ?
) or \`order\`.id in 
-- Recurrence
(
	SELECT \`order\`.id
FROM   \`order\`
INNER JOIN contract on contract.id = \`order\`.contractId
INNER JOIN recurrence on contract.recurrenceId = recurrence.id
WHERE  ( recurrencetype = 'daily'
         AND Mod(Dayofweek(?), recurrence.timevalue) = 0 )
        OR ( recurrencetype = 'weekly'
             AND Mod(Week(?), recurrence.timevalue) = 0 )
        OR ( recurrencetype = 'monthByDayNo'
             AND Day(?) = recurrence.recurrencedayno
             AND Mod(Month(?), recurrence.recurrencemonthno) = 0 )
        OR ( recurrencetype = 'monthByDay'
             AND Floor((Dayofmonth(CURRENT_DATE()) - 1) / 7)
                 + 1 = recurrence.recurrenceweekno
             AND Dayofweek(?) = recurrence.recurrencedayno )
        OR ( recurrencetype = 'year'
             AND Mod(( ? ), recurrence.timevalue) = 0 )
        OR ( recurrencetype = 'yearByDayNo'
             AND Month(?) = recurrence.recurrencemonthno
             AND Day(?) = recurrence.timevalue )
        OR ( recurrencetype = 'yearByDay'
             AND Floor((Dayofmonth(CURRENT_DATE()) - 1) / 7)
                 + 1 = recurrence.recurrenceweekno
             AND Dayofweek(?) = recurrence.recurrencedayno
             AND Month(?) = recurrence.recurrencemonthno )
)

-- other conditions
and orderTypeId = 8
and orderStatusId = 2
${searchSQL}

${orderBySQL}

-- Other (Pagination for the nation)
limit 10 offset ?
    `, params);



    let countParams = params;
    countParams.pop();
    const count = await this.repo.query(`
    SELECT count(*) FROM \`order\`
    LEFT JOIN order_type on order_type.id = \`order\`.orderTypeId
    LEFT JOIN account on account.id = \`order\`.accountId
    -- Standard query for date range
    where \`order\`.id in (
      select id from \`order\`
        where \`order\`.orderStatusId = 2 and
        (\`order\`.contractId is null or \`order\`.contractId = -1)
      and \`order\`.date = ?
    ) or \`order\`.id in 
    -- Recurrence
    (
      SELECT \`order\`.id
    FROM   \`order\`
    INNER JOIN contract on contract.id = \`order\`.contractId
    INNER JOIN recurrence on contract.recurrenceId = recurrence.id
    WHERE  ( recurrencetype = 'daily'
             AND Mod(Dayofweek(?), recurrence.timevalue) = 0 )
            OR ( recurrencetype = 'weekly'
                 AND Mod(Week(?), recurrence.timevalue) = 0 )
            OR ( recurrencetype = 'monthByDayNo'
                 AND Day(?) = recurrence.recurrencedayno
                 AND Mod(Month(?), recurrence.recurrencemonthno) = 0 )
            OR ( recurrencetype = 'monthByDay'
                 AND Floor((Dayofmonth(CURRENT_DATE()) - 1) / 7)
                     + 1 = recurrence.recurrenceweekno
                 AND Dayofweek(?) = recurrence.recurrencedayno )
            OR ( recurrencetype = 'year'
                 AND Mod(( ? ), recurrence.timevalue) = 0 )
            OR ( recurrencetype = 'yearByDayNo'
                 AND Month(?) = recurrence.recurrencemonthno
                 AND Day(?) = recurrence.timevalue )
            OR ( recurrencetype = 'yearByDay'
                 AND Floor((Dayofmonth(CURRENT_DATE()) - 1) / 7)
                     + 1 = recurrence.recurrenceweekno
                 AND Dayofweek(?) = recurrence.recurrencedayno
                 AND Month(?) = recurrence.recurrencemonthno )
    )
    
    -- other conditions
    and orderTypeId = 8
    and orderStatusId = 2
    ${searchSQL}
    
    ${orderBySQL}
    
    -- Other (Pagination for the nation)
        `, countParams);

    const ids = [];
    results.forEach((result) => {
      ids.push(result.id);
    });
    
    if(ids.length === 0) {
      return {count: 0, data: []};
    }
    // now do a query builder query to get orders based on ids from inital query
    const query = this.repo.createQueryBuilder()
    .whereInIds(ids)
    .leftJoinAndSelect('updatedUser', 'updatedUser')
    .leftJoinAndSelect('orderType', 'orderType')
    .leftJoinAndSelect('account', 'account')
    .leftJoinAndSelect('site', 'site')
    .leftJoinAndSelect('orderStatus', 'orderStatus')
    .leftJoinAndSelect('skipOrderType', 'skipOrderType')
    // .leftJoinAndSelect('containerSizeType', 'containerSizeType')
    // .leftJoinAndSelect('containerSizeType.unit', 'containerSizeType.unit')
    .leftJoinAndSelect('containerType', 'containerType')
    .leftJoinAndSelect('grade', 'grade')
    .leftJoinAndSelect('tipSite', 'tipSite')
    
    return {data: await query.getMany(), count: count[0]['count(*)']};
  }
  async copyOrderToDates(orderId: number, dates: string[]) {
    if(!orderId) {
      throw new Error('You must provide a order id in orderservice copy to dates method');
    }

    if(!dates) {
      throw new Error('You must provide dates in the copy to dates method in order service');
    }

    if(dates.length === 0) {
      throw new Error('You must provide at least one date in the copy to dates method in order service');
    }

    const currentOrder = await this.repo.findOne(orderId);

    const orderLines = await this.orderLineService.getAllOrderLinesForOrderId(orderId);


    for(let i =0; i < dates.length; i++) {
      const date = dates[i];
      let newOrder = JSON.parse(JSON.stringify(currentOrder));
      newOrder.date = date;
      delete newOrder.id;

      newOrder = await this.repo.save(newOrder);

      const newOrderLines = JSON.parse(JSON.stringify(orderLines));

      newOrderLines.forEach((line: OrderLine) => {
        delete line.id;
        line.orderId = newOrder.id;

        if(line.order === undefined) {
          line.order = new Order();
        }

        line.order.id = newOrder.id;
      });

     await this.orderLineService.bulkSaveOrderLines(newOrderLines);
    }

  }

  async acceptOrder(id: number) {
    if(!id) {
      throw new Error('You must provide an id in orderService accept method');
    }

    const order = await this.repo.findOne(id, {
      relations: ['orderType', 'account', 'site', 'orderStatus']
    });

    await this.orderHistoryStatusService.updateOrderStatusHistory(order.id, 2);

    // TODO: to address change this to actual when accounts setup
    let toAddress = 'mark.lang@fourways-technology.co.uk';

    await this.mailService.sendEmailWithTemplate(toAddress, "Waste System | Order #" + order.id + " Accepted", 'order-accept', order);

    // update status of the order to accepted 
    order.orderStatusId = 2;
    order.orderStatus.id = order.orderStatusId;


    // check if confirmation email is required
    if(order.sendConfirmationEmail) {
      // send confirmation email as well.
      if(order.site.email && order.site.email !== '') {
        toAddress = order.site.email;
      } else {
        toAddress = order.account.email;
      }

      await this.mailService.sendEmailWithTemplate(toAddress, "Order Confirmation", 'order-confirmation', order);

    }



    this.repo.save(order);

    return order;

  }

  async declineOrder(id: number, reason: string='') {
    if(!id) {
      throw new Error('You must provide an id in orderService decline method');
    }

    const order = await this.repo.findOne(id, {
      relations: ['orderType', 'account', 'site', 'orderStatus']
    });

    await this.orderHistoryStatusService.updateOrderStatusHistory(order.id, 3, reason);

    // TODO: to address change this to actual when accounts setup
    const toAddress = 'mark.lang@fourways-technology.co.uk';

    await this.mailService.sendEmailWithTemplate(toAddress, "Waste System | Order #" + order.id + " Declined", 'order-decline', order);

    // update status of the order to accepted 
    order.orderStatusId = 3;
    order.orderStatus.id = order.orderStatusId;

    this.repo.save(order);

    return order;

  }

  async getSameCustomerAndSite() {
    return this.repo.manager.query(`
    select 
      o.id as OrderId, a.name as AccountName, b.name as SiteName, order_status.name as Status, o.date as OrderDate
    from \`order\` o  
      inner join account a on a.id = o.accountId 
      inner join account b on b.id = o.siteId 
      inner join order_status on order_status.id = o.orderStatusId 
      where b.name = a.name
    `);
  }
  
  /* New Work */
  async findOrderIdFromProductName(data) {
    const params: any[] = [];
    params.push(data.data['Depot Ref']);
    const results = await this.repo.query('select id from `order` where driverNotes = ? LIMIT 1',params);
    return results;
}
  async SaveOrderProvision(data) {

    const params: any[] = [];
    params.push(new Date(data.data['Date']));
    params.push(data.data['orderid']);
    params.push('1');
    params.push('1');
    params.push('1');
    params.push(data.data['LoadId']);
    params.push('0');
    const results =  await this.repo.query(`
     CALL sp_insert_orderprovision(?,?,?,?,?,?,?);
    `,params);
  return data.data;
    
    
   
}
async ArticProvissionOrders() {

  
  // const results =  await this.repo.query(`
  //   SELECT * FROM order_provision op WHERE op.allocated = 0;
  // `);

  const results =  await this.repo.query('select * from `order` where ordertypeId = 4');

  return results;
  
  
  
}
async UpdateOrderProvisionAllocation(data) {

  
  const results =  await this.repo.query(`
  UPDATE order_provision SET allocated = 1 WHERE id = ? and orderId = ?;
  `,[data.provissionId, data.orderId]);
  return results;
 
}
}

